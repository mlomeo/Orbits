<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Orbiting Satellite</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            width: 220px;
            transition: width 0.2s;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        #controls {
            background: rgba(255,255,255,0.92);
            padding: 10px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 180px;
            max-width: 220px;
            transition: opacity 0.2s;
            box-sizing: border-box;
        }
        #controls.minimized {
            opacity: 0;
            pointer-events: none;
            position: absolute;
        }
        #minimize-btn {
            align-self: flex-end;
            background: #fff;
            color: #1e90ff;
            border: none;
            border-radius: 6px;
            padding: 3px 10px;
            font-size: 1.1em;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 2px;
            box-shadow: 0 1px 4px rgba(30,144,255,0.07);
            outline: none;
            transition: background 0.18s, color 0.18s;
        }
        #minimize-btn:hover {
            background: #e0e0e0;
            color: #1565c0;
        }
        #controls-panel.minimized {
            width: 44px;
        }
        #controls-panel.minimized #controls {
            display: none;
        }
        #controls-panel.minimized #minimize-btn {
            align-self: flex-start;
            margin-bottom: 0;
            margin-top: 0;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 1.2em;
        }
        #controls label {
            display: flex;
            align-items: center;
            margin-bottom: 7px;
            font-size: 0.97em;
            flex-wrap: wrap;
            gap: 4px;
        }
        #controls input[type="text"] {
            width: 42px;
            min-width: 0;
            max-width: 54px;
            padding: 2px 4px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            background: #f7f9fb;
            font-size: 0.97em;
            margin-right: 4px;
            box-sizing: border-box;
        }
        #controls input[type="range"] {
            flex: 1 1 90px;
            min-width: 90px;
            max-width: 120px;
            accent-color: #1e90ff;
            margin-left: 4px;
            margin-right: 4px;
            height: 2px;
            box-sizing: border-box;
        }
        #controls span {
            min-width: 32px;
            text-align: right;
            font-size: 0.97em;
            color: #1e90ff;
            font-weight: 500;
            margin-left: 2px;
        }
        #controls button {
            margin-top: 0;
            margin-bottom: 0;
            margin-right: 0;
            padding: 5px 0;
            border: none;
            border-radius: 5px;
            background: #f7f9fb;
            color: #1e90ff;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            box-shadow: none;
            transition: background 0.18s, color 0.18s;
            outline: none;
            width: 100%;
        }
        #controls button:hover {
            background: #e0e0e0;
            color: #1565c0;
        }
        #controls .button-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 2px;
        }
        .toggle-switch {
            display: inline-block;
            position: relative;
            width: 32px;
            height: 16px;
            margin-left: 6px;
        }
        .toggle-switch input[type="checkbox"] {
            display: none;
        }
        .toggle-switch label {
            display: block;
            width: 100%;
            height: 100%;
            background: #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            position: absolute;
        }
        .toggle-switch input[type="checkbox"]:checked + label {
            background: #1e90ff;
        }
        .toggle-switch label:after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
        }
        .toggle-switch input[type="checkbox"]:checked + label:after {
            left: 18px;
        }
        #distance-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255,255,255,0.92);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1em;
            color: #1e90ff;
            box-shadow: none;
            border: 1px solid #e0e0e0;
            z-index: 10;
        }
        #poca-display {
            position: absolute;
            bottom: 40px;
            left: 10px;
            background: rgba(255,255,255,0.92);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1em;
            color: #1e90ff;
            box-shadow: none;
            border: 1px solid #e0e0e0;
            z-index: 10;
        }
        #chart-container {
            position: absolute;
            bottom: 70px;
            left: 10px;
            width: 400px;
            height: 250px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: none;
            z-index: 10;
        }
        .dropdown {
            margin-bottom: 8px;
            width: 100%;
        }
        .dropdown-toggle {
            width: 100%;
            background: #f7f9fb;
            color: #1e90ff;
            border: none;
            border-radius: 5px;
            padding: 6px 0;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            text-align: left;
            transition: background 0.18s, color 0.18s;
            outline: none;
        }
        .dropdown-toggle:hover {
            background: #e0e0e0;
            color: #1565c0;
        }
        .dropdown-content {
            display: none;
            flex-direction: column;
            gap: 6px;
            margin-top: 4px;
            margin-bottom: 4px;
            padding-left: 4px;
        }
        .dropdown.open .dropdown-content {
            display: flex;
        }
        @media (max-width: 600px) {
            #controls-panel { left: 1vw; width: 98vw; }
            #controls { min-width: 140px; padding: 6px; }
            #chart-container { width: 98vw; left: 1vw; }
        }
    </style>
</head>
<body>
    <div id="controls-panel">
        <button id="minimize-btn" title="Minimize/Expand Panel">☰</button>
        <div id="controls">
            <h3>Earth & Sun Toggle</h3>
            <label>
                Show Earth:
                <span class="toggle-switch">
                    <input type="checkbox" id="earthToggle" checked>
                    <label for="earthToggle"></label>
                </span>
            </label>
            <label>
                Show Sun:
                <span class="toggle-switch">
                    <input type="checkbox" id="sunToggle" checked>
                    <label for="sunToggle"></label>
                </span>
            </label>
            
            <div class="dropdown">
                <button class="dropdown-toggle" id="sat1-toggle">Satellite 1 ▼</button>
                <div class="dropdown-content" id="sat1-content">
                    <label>
                        Altitude (km):
                        <input type="text" id="alt1-text" value="500" size="5">
                    </label>
                    <label>
                        Inclination (deg):
                        <input type="text" id="incl1-text" value="60" size="5">
                    </label>
                    <label>
                        Eccentricity:
                        <input type="text" id="ecc1-text" value="0" size="5">
                    </label>
                    <label>
                        RAAN (deg):
                        <input type="text" id="raan1-text" value="0" size="5">
                    </label>
                    <label>
                        Argument of Perigee (deg):
                        <input type="text" id="argp1-text" value="0" size="5">
                    </label>
                </div>
            </div>
            <div class="dropdown">
                <button class="dropdown-toggle" id="sat2-toggle">Satellite 2 ▼</button>
                <div class="dropdown-content" id="sat2-content">
                    <label>
                        Altitude (km):
                        <input type="text" id="alt2-text" value="500" size="5">
                    </label>
                    <label>
                        Inclination (deg):
                        <input type="text" id="incl2-text" value="60" size="5">
                    </label>
                    <label>
                        Eccentricity:
                        <input type="text" id="ecc2-text" value="0" size="5">
                    </label>
                    <label>
                        RAAN (deg):
                        <input type="text" id="raan2-text" value="0" size="5">
                    </label>
                    <label>
                        Argument of Perigee (deg):
                        <input type="text" id="argp2-text" value="0" size="5">
                    </label>
                </div>
            </div>
            <button id="apply">Apply Changes</button>
            <div class="dropdown">
                <button class="dropdown-toggle" id="views-toggle">Views ▼</button>
                <div class="dropdown-content" id="views-content">
                    <button id="snap-sat1">Snap to Sat1 Plane (2D View)</button>
                    <button id="snap-sat2">Snap to Sat2 Plane (2D View)</button>
                    <button id="center-sat1">Center on Sat1</button>
                    <button id="center-sat2">Center on Sat2</button>
                    <button id="center-earth">Center on Earth</button>
                    <button id="reset-view">Reset View</button>
                </div>
            </div>
            <div class="dropdown">
                <button class="dropdown-toggle" id="preset-toggle">Presets ▼</button>
                <div class="dropdown-content" id="preset-content">
                    <button id="preset-inc-offset">Inc Offset</button>
                </div>
            </div>
            <button id="pause-btn">Pause</button>
        </div>
    </div>
    <div id="distance-display">Distance between Sat1 and Sat2: 0 km</div>
    <div id="poca-display">POCA: 0 km</div>
    <div id="chart-container">
        <canvas id="distanceChart"></canvas>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        // Create scene
        var scene = new THREE.Scene();

        // Create camera
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Create renderer
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff, 1); // White background
        document.body.appendChild(renderer.domElement);

        // Add orbit controls for interaction (pan, zoom, rotate)
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // Add ambient light for subtle illumination
        var ambientLight = new THREE.AmbientLight(0x333333, 0.2); // Dim ambient light
        scene.add(ambientLight);

        // Sun object (yellow sphere, not to size)
        var sunGeometry = new THREE.SphereGeometry(3, 32, 32);
        var sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        var sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(0, 0, 0);
        scene.add(sun);

        // Light source from the sun (PointLight with no decay for constant illumination)
        var sunLight = new THREE.PointLight(0xffffff, 5, 0, 0); // High intensity, infinite distance, no decay
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);

        // Earth as a blue dot
        var earthGeometry = new THREE.SphereGeometry(1, 32, 32); // Radius 1 instead of 5
        var earthMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 10 }); // Blue color
        var earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(50, 0, 0); // Initial position orbiting sun
        scene.add(earth);

        // Small blue dot at Earth's center (always visible)
        var centerDotGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        var centerDotMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
        var centerDot = new THREE.Mesh(centerDotGeometry, centerDotMaterial);
        scene.add(centerDot);

        // Satellite 1 (red sphere model, no lighting)
        var satelliteGeometry1 = new THREE.SphereGeometry(0.2, 6, 6);
        var satelliteMaterial1 = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color, no lighting
        var satellite1 = new THREE.Mesh(satelliteGeometry1, satelliteMaterial1);
        scene.add(satellite1);

        // Satellite 2 (green sphere model, no lighting)
        var satelliteGeometry2 = new THREE.SphereGeometry(0.2, 6, 6);
        var satelliteMaterial2 = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green color, no lighting
        var satellite2 = new THREE.Mesh(satelliteGeometry2, satelliteMaterial2);
        scene.add(satellite2);

        // Trace group (follows Earth's position but not rotation)
        var traceGroup = new THREE.Group();
        scene.add(traceGroup);

        // Orbit traces (as children of traceGroup)
        let positions1 = [];
        let positions2 = [];
        let maxPoints = 1656; // Approximate for 3 orbits (552 points per orbit for dt=10s, T~5520s)
        var traceMaterial1 = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var traceGeometry1 = new THREE.BufferGeometry();
        var trace1 = new THREE.Line(traceGeometry1, traceMaterial1);
        traceGroup.add(trace1);
        var traceMaterial2 = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        var traceGeometry2 = new THREE.BufferGeometry();
        var trace2 = new THREE.Line(traceGeometry2, traceMaterial2);
        traceGroup.add(trace2);

        // Background grid (in x-y plane, following Earth)
        var grid = new THREE.GridHelper(50, 10, 0x000000, 0x000000);
        grid.rotation.x = Math.PI / 2;
        scene.add(grid);

        // Constants for orbital mechanics (units in km, s)
        const GM = 3.986004418e5; // km^3/s^2
        const J2 = 1.08262668e-3;
        const R_e = 6378.137; // km
        const earthRadiusViz = 5;

        // Function to initialize satellite state with RAAN and Argument of Perigee
        function initSatState(altitude, inclination, eccentricity, raan, argp) {
            const a_real = R_e + altitude;
            const incl_rad = inclination * Math.PI / 180;
            const raan_rad = raan * Math.PI / 180;
            const argp_rad = argp * Math.PI / 180;

            // Start at periapsis
            const r_peri = a_real * (1 - eccentricity);
            const v_peri = Math.sqrt(GM * (2 / r_peri - 1 / a_real));

            // Position in perifocal coordinates
            const pos_perifocal = new THREE.Vector3(r_peri, 0, 0);

            // Velocity in perifocal coordinates
            const vel_perifocal = new THREE.Vector3(0, v_peri, 0);

            // Rotation matrices for RAAN, inclination, and argument of perigee
            const rot_raan = new THREE.Matrix4().makeRotationZ(raan_rad);
            const rot_incl = new THREE.Matrix4().makeRotationX(incl_rad);
            const rot_argp = new THREE.Matrix4().makeRotationZ(argp_rad);

            // Combined rotation matrix
            const rotationMatrix = new THREE.Matrix4()
                .multiply(rot_raan)
                .multiply(rot_incl)
                .multiply(rot_argp);

            // Transform position and velocity to ECI frame
            const pos_eci = pos_perifocal.applyMatrix4(rotationMatrix);
            const vel_eci = vel_perifocal.applyMatrix4(rotationMatrix);

            return {
                pos: pos_eci,
                vel: vel_eci
            };
        }

        // Initial states
        let satState1 = initSatState(500, 60, 0, 0, 0);
        let satState2 = initSatState(500, 60, 0, 0, 0);

        // Function to compute acceleration (2-body + J2)
        function getAcceleration(pos) {
            const r = pos.length();
            const a2b = pos.clone().multiplyScalar(-GM / (r * r * r));

            const factor = - (3 / 2) * J2 * (GM / (r * r)) * Math.pow(R_e / r, 2);
            const z2_r2 = (pos.z * pos.z) / (r * r);
            const ax_j2 = factor * (pos.x / r) * (5 * z2_r2 - 1);
            const ay_j2 = factor * (pos.y / r) * (5 * z2_r2 - 1);
            const az_j2 = factor * (pos.z / r) * (5 * z2_r2 - 3);
            const a_j2 = new THREE.Vector3(ax_j2, ay_j2, az_j2);

            return a2b.add(a_j2);
        }

        // RK4 integrator (adapted for vectors)
        function rk4(pos, vel, dt) {
            const acc = (p, v, t) => getAcceleration(p); // Ignore v and t for this model

            const vel1 = vel.clone();
            const acc1 = acc(pos, vel, 0);

            const pos2 = pos.clone().add(vel1.clone().multiplyScalar(dt / 2));
            const vel2 = vel.clone().add(acc1.clone().multiplyScalar(dt / 2));
            const acc2 = acc(pos2, vel2, dt / 2);

            const pos3 = pos.clone().add(vel2.clone().multiplyScalar(dt / 2));
            const vel3 = vel.clone().add(acc2.clone().multiplyScalar(dt / 2));
            const acc3 = acc(pos3, vel3, dt / 2);

            const pos4 = pos.clone().add(vel3.clone().multiplyScalar(dt));
            const vel4 = vel.clone().add(acc3.clone().multiplyScalar(dt));
            const acc4 = acc(pos4, vel4, dt);

            const posf = pos.clone().add(
                vel1.clone().add(vel2.clone().multiplyScalar(2)).add(vel3.clone().multiplyScalar(2)).add(vel4)
                .multiplyScalar(dt / 6)
            );

            const velf = vel.clone().add(
                acc1.clone().add(acc2.clone().multiplyScalar(2)).add(acc3.clone().multiplyScalar(2)).add(acc4)
                .multiplyScalar(dt / 6)
            );

            return { pos: posf, vel: velf };
        }

        // Orbit parameters for Earth around sun (simple)
        var earthOrbitRadius = 50;
        var earthTheta = 0;
        var dEarthTheta = 2 * Math.PI / 5000; // Slow orbit speed

        // Set initial camera and controls to center on Earth
        camera.position.set(50, 0, 15); // Position above the ecliptic plane
        controls.target.copy(earth.position);
        var previousTarget = new THREE.Vector3().copy(earth.position);

        // Time step for integration (s per frame, adjust for speed/accuracy)
        const dt = 10; // Seconds per frame (tune to control simulation speed)

        // Current center
        let currentCenter = 'earth';

        // Simulated time
        let simulatedTime = 0;

        // Chart setup
        const ctx = document.getElementById('distanceChart').getContext('2d');
        const distanceChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [], // Time
                datasets: [{
                    label: 'Distance between Sat1 and Sat2 (km)',
                    data: [],
                    borderColor: '#1E90FF',
                    backgroundColor: 'rgba(30, 144, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        labels: {
                            font: { size: 14 }
                        }
                    },
                    tooltip: {
                        mode: 'nearest',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                return `Distance: ${context.parsed.y.toFixed(2)} km`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (s)',
                            font: { size: 14 }
                        },
                        grid: { display: false },
                        ticks: { maxTicksLimit: 10 }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Distance (km)',
                            font: { size: 14 }
                        },
                        grid: { color: '#e0e0e0' },
                        suggestedMin: 0
                    }
                }
            }
        });
        let chartData = { time: [], dist: [] };

        // Chart update interval (every 20 frames, ~200s)
        const chartUpdateInterval = 20;
        let frameCount = 0;

        // Update displays: only sync text inputs (no sliders)
        function updateDisplays() {
            // No slider syncing needed
        }

        // Update event listeners for text boxes only
        ['alt1-text', 'incl1-text', 'ecc1-text', 'alt2-text', 'incl2-text', 'ecc2-text'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateDisplays);
        });

        // Apply button to reset satellite states
        document.getElementById('apply').addEventListener('click', () => {
            const alt1 = parseFloat(document.getElementById('alt1-text').value);
            const incl1 = parseFloat(document.getElementById('incl1-text').value);
            const ecc1 = parseFloat(document.getElementById('ecc1-text').value);
            const raan1 = parseFloat(document.getElementById('raan1-text').value);
            const argp1 = parseFloat(document.getElementById('argp1-text').value);

            const alt2 = parseFloat(document.getElementById('alt2-text').value);
            const incl2 = parseFloat(document.getElementById('incl2-text').value);
            const ecc2 = parseFloat(document.getElementById('ecc2-text').value);
            const raan2 = parseFloat(document.getElementById('raan2-text').value);
            const argp2 = parseFloat(document.getElementById('argp2-text').value);

            satState1 = initSatState(alt1, incl1, ecc1, raan1, argp1);
            satState2 = initSatState(alt2, incl2, ecc2, raan2, argp2);

            // Reset POCA calculation
            poca = Infinity;

            // Reset traces and chart when applying changes
            positions1 = [];
            positions2 = [];
            chartData.time = [];
            chartData.dist = [];
            distanceChart.data.labels = [];
            distanceChart.data.datasets[0].data = [];
            distanceChart.update();
            simulatedTime = 0;
            frameCount = 0;
        });

        // Snap to Sat1 plane
        document.getElementById('snap-sat1').addEventListener('click', () => {
            currentCenter = 'earth';
            const normal = satState1.pos.clone().cross(satState1.vel).normalize().multiplyScalar(20);
            camera.position.copy(earth.position.clone().add(normal));
            camera.lookAt(earth.position);
            controls.target.copy(earth.position);
        });

        // Snap to Sat2 plane
        document.getElementById('snap-sat2').addEventListener('click', () => {
            currentCenter = 'earth';
            const normal = satState2.pos.clone().cross(satState2.vel).normalize().multiplyScalar(20);
            camera.position.copy(earth.position.clone().add(normal));
            camera.lookAt(earth.position);
            controls.target.copy(earth.position);
        });

        // Center on Sat1
        document.getElementById('center-sat1').addEventListener('click', () => {
            currentCenter = 'sat1';
            camera.position.copy(satellite1.position.clone().add(new THREE.Vector3(0, 0, 10)));
            camera.lookAt(satellite1.position);
            controls.target.copy(satellite1.position);
            previousTarget.copy(satellite1.position);
        });

        // Center on Sat2
        document.getElementById('center-sat2').addEventListener('click', () => {
            currentCenter = 'sat2';
            camera.position.copy(satellite2.position.clone().add(new THREE.Vector3(0, 0, 10)));
            camera.lookAt(satellite2.position);
            controls.target.copy(satellite2.position);
            previousTarget.copy(satellite2.position);
        });

        // Center on Earth
        document.getElementById('center-earth').addEventListener('click', () => {
            currentCenter = 'earth';
            camera.position.copy(earth.position.clone().add(new THREE.Vector3(0, 0, 15)));
            camera.lookAt(earth.position);
            controls.target.copy(earth.position);
            previousTarget.copy(earth.position);
        });

        // Reset view
        document.getElementById('reset-view').addEventListener('click', () => {
            currentCenter = 'earth';
            camera.position.copy(earth.position.clone().add(new THREE.Vector3(0, 0, 15)));
            camera.lookAt(earth.position);
            controls.target.copy(earth.position);
            previousTarget.copy(earth.position);
        });

        // Pause state
        let paused = false;

        // Pause button logic
        const pauseBtn = document.getElementById('pause-btn');
        pauseBtn.addEventListener('click', () => {
            paused = !paused;
            pauseBtn.textContent = paused ? 'Resume' : 'Pause';
        });

        // Function to calculate the maximum number of points for the last 3 orbits
        function getMaxPoints() {
            const a1 = R_e + parseFloat(document.getElementById('alt1-text').value);
            const period1 = 2 * Math.PI * Math.sqrt(a1 ** 3 / GM);
            const a2 = R_e + parseFloat(document.getElementById('alt2-text').value);
            const period2 = 2 * Math.PI * Math.sqrt(a2 ** 3 / GM);
            const maxTimeSpan = 3 * Math.max(period1, period2); // Last 3 orbits
            return Math.ceil(maxTimeSpan / dt); // Convert time span to points
        }

        let poca = Infinity; // Initialize POCA to a very large value

        // Add this function before the updatePOCA function:
        function getPOCAThreshold() {
            const alt1 = parseFloat(document.getElementById('alt1-text').value);
            const a1 = R_e + alt1;
            const period1 = 2 * Math.PI * Math.sqrt(Math.pow(a1, 3) / GM);
            const alt2 = parseFloat(document.getElementById('alt2-text').value);
            const a2 = R_e + alt2;
            const period2 = 2 * Math.PI * Math.sqrt(Math.pow(a2, 3) / GM);
            return Math.max(period1, period2);
        }

        // Modify updatePOCA to start tracking after one orbital period:
        function updatePOCA(distance) {
            if (simulatedTime > getPOCAThreshold()) {
                if (distance > 0 && distance < poca) {
                    poca = distance;
                    document.getElementById('poca-display').textContent = `POCA: ${poca.toFixed(2)} km`;
                }
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (!paused) {
                // Rotate Earth on its axis
                earth.rotation.y += 0.001;

                // Update Earth position (simple orbit around sun)
                earthTheta += dEarthTheta;
                earth.position.x = earthOrbitRadius * Math.cos(earthTheta);
                earth.position.y = earthOrbitRadius * Math.sin(earthTheta);
                earth.position.z = 0;

                // Propagate satellite 1 using RK4 with 2-body + J2
                satState1 = rk4(satState1.pos, satState1.vel, dt);

                // Set satellite 1 visual position (relative to Earth, scaled)
                const scale1 = earthRadiusViz / R_e;
                const satPosViz1 = satState1.pos.clone().multiplyScalar(scale1);
                satellite1.position.copy(earth.position.clone().add(satPosViz1));

                // Propagate satellite 2 using RK4 with 2-body + J2
                satState2 = rk4(satState2.pos, satState2.vel, dt);

                // Set satellite 2 visual position (relative to Earth, scaled)
                const scale2 = earthRadiusViz / R_e;
                const satPosViz2 = satState2.pos.clone().multiplyScalar(scale2);
                satellite2.position.copy(earth.position.clone().add(satPosViz2));

                // Update distance display
                const dist = satState1.pos.distanceTo(satState2.pos);
                document.getElementById('distance-display').textContent = `Distance between Sat1 and Sat2: ${dist.toFixed(2)} km`;

                // Update POCA
                updatePOCA(dist);

                // Update orbit traces (relative to Earth)
                positions1.push(satPosViz1.clone());
                if (positions1.length > maxPoints) positions1.shift();
                traceGeometry1.setFromPoints(positions1);

                positions2.push(satPosViz2.clone());
                if (positions2.length > maxPoints) positions2.shift();
                traceGeometry2.setFromPoints(positions2);

                // Update traceGroup position
                traceGroup.position.copy(earth.position);

                // Update chart less frequently
                frameCount++;
                if (frameCount % chartUpdateInterval === 0) {
                    simulatedTime += dt * chartUpdateInterval;
                    chartData.time.push(simulatedTime);
                    chartData.dist.push(satState1.pos.distanceTo(satState2.pos));

                    // Keep only the last 3 orbits of data
                    maxPoints = getMaxPoints();
                    while (chartData.time.length > maxPoints) {
                        chartData.time.shift();
                        chartData.dist.shift();
                    }

                    distanceChart.data.labels = chartData.time;
                    distanceChart.data.datasets[0].data = chartData.dist;
                    distanceChart.update();
                }
            }

            // Always update center dot position and grid position
            centerDot.position.copy(earth.position);
            grid.position.x = earth.position.x;
            grid.position.y = earth.position.y;
            grid.position.z = 0;

            // Always update controls target and camera follow based on current center
            let targetPos;
            if (currentCenter === 'sat1') {
                targetPos = satellite1.position;
            } else if (currentCenter === 'sat2') {
                targetPos = satellite2.position;
            } else {
                targetPos = earth.position;
            }
            controls.target.copy(targetPos);
            var delta = new THREE.Vector3().copy(targetPos).sub(previousTarget);
            camera.position.add(delta);
            previousTarget.copy(targetPos);

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Minimize panel logic
        const controlsPanel = document.getElementById('controls-panel');
        const controlsDiv = document.getElementById('controls');
        const minimizeBtn = document.getElementById('minimize-btn');
        let minimized = false;
        function updateMinimizeBtn() {
            minimizeBtn.textContent = minimized ? '☰' : '×';
            minimizeBtn.title = minimized ? 'Expand Panel' : 'Minimize Panel';
        }
        minimizeBtn.addEventListener('click', () => {
            minimized = !minimized;
            controlsPanel.classList.toggle('minimized', minimized);
            controlsDiv.classList.toggle('minimized', minimized);
            updateMinimizeBtn();
        });
        updateMinimizeBtn();

        // Dropdown logic
        function setupDropdown(toggleId, contentId) {
            const toggle = document.getElementById(toggleId);
            const content = document.getElementById(contentId);
            const parent = toggle.parentElement;
            toggle.addEventListener('click', () => {
                parent.classList.toggle('open');
                // Change arrow direction
                if (parent.classList.contains('open')) {
                    toggle.textContent = toggle.textContent.replace('▼', '▲');
                } else {
                    toggle.textContent = toggle.textContent.replace('▲', '▼');
                }
            });
        }
        setupDropdown('sat1-toggle', 'sat1-content');
        setupDropdown('sat2-toggle', 'sat2-content');
        setupDropdown('views-toggle', 'views-content');
        setupDropdown('preset-toggle', 'preset-content');

        // Earth toggle
        document.getElementById('earthToggle').addEventListener('change', function(e) {
            earth.visible = e.target.checked;
        });

        // Sun toggle
        document.getElementById('sunToggle').addEventListener('change', function(e) {
            sun.visible = e.target.checked;
            sunLight.visible = e.target.checked;
        });

        // Function to apply the "Inc Offset" preset
        function applyIncOffsetPreset() {
            // Set Sat1 initial conditions
            document.getElementById('alt1-text').value = 500;
            document.getElementById('incl1-text').value = 90;
            document.getElementById('ecc1-text').value = 0;
            document.getElementById('raan1-text').value = 0;
            document.getElementById('argp1-text').value = 0;

            // Set Sat2 initial conditions
            document.getElementById('alt2-text').value = 500;
            document.getElementById('incl2-text').value = 88;
            document.getElementById('ecc2-text').value = 0;
            document.getElementById('raan2-text').value = 0;
            document.getElementById('argp2-text').value = 0;

            // Trigger the Apply Changes button logic (which resets POCA)
            document.getElementById('apply').click();

            // Also ensure POCA is reset in case needed here:
            poca = Infinity;

            // Restart simulation
            positions1 = [];
            positions2 = [];
            chartData.time = [];
            chartData.dist = [];
            distanceChart.data.labels = [];
            distanceChart.data.datasets[0].data = [];
            distanceChart.update();
            simulatedTime = 0;
            frameCount = 0;
        }

        // Event listener for "Inc Offset" preset
        document.getElementById('preset-inc-offset').addEventListener('click', applyIncOffsetPreset);
    </script>
</body>
</html>